# -*- coding: utf-8 -*-
"""09-Diameter-of-Binary-Tree--Leet-Code-543

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RkiakiplhOTc2GuVX-c1MSrUa5Lh7u86

To find the diameter of a binary tree, we need to find the longest path between any two nodes in the tree. 
    We can do this by recursively traversing the tree and keeping track of the longest path found so far. 
    We can compute the length of the path passing through the root by adding the height of its left and right subtrees. 
    The maximum diameter is the maximum of the diameter of its left and right subtrees or the length passing through the root.

**Solution 01**
"""

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.diameter = 0
        self.get_h(root)        
        return self.diameter
    
    def get_h(self, node: TreeNode) -> int:
        if node is None:
            return 0

        left_h = self.get_h(node.left)
        right_h = self.get_h(node.right)
        self.diameter = max(self.diameter, left_h + right_h)

        return 1 + max(left_h, right_h)

"""**Solution 02**"""

class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        diameter = 0

        def dfs(root):
            nonlocal diameter

            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            diameter = max(diameter, left + right)

            return 1 + max(left, right)

        dfs(root)
        return diameter