# -*- coding: utf-8 -*-
"""08-Maximum-Depth-of-Binary-Tree--Leet-Code-104

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UykMih4Bma4kMZQ2ev5AI5vA_wAy-h8P

**Solution using BFS:**

    To find the maximum depth of a binary tree using BFS, we can use a queue to store the nodes and their depths as we traverse the tree level by level. 
    At each level, we increment the depth and add the child nodes to the queue until there are no more nodes left to process. 
    The maximum depth will be the maximum depth seen during the traversal.
"""

def maxDepth(root):
    if not root:
        return 0
    
    queue = [(root, 1)]
    max_depth = 0
    
    while queue:
        node, depth = queue.pop(0)
        
        if node.left:
            queue.append((node.left, depth + 1))
            
        if node.right:
            queue.append((node.right, depth + 1))
            
        max_depth = max(max_depth, depth)
        
    return max_depth

"""**Solution using DFS:**

    To find the maximum depth of a binary tree using DFS, we can traverse the tree recursively and keep track of the maximum depth seen so far. 
    We can do this by passing the current depth as a parameter to the recursive function.

***Algorithm:***

    1.   If the root is null, return 0.
    2.   If the root has no children, return 1.
    3.   Recursively compute the maximum depth of the left subtree and the right subtree.
    4.   Return the maximum of the depths of the left and right subtrees plus 1.
"""

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)

        if l > r:
            return l + 1

        return r + 1